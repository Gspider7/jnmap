package com.jia.jnmap.nmap.vuln;

import com.gaff.staff.cpe.WFN;
import com.gaff.staff.cpe.WFNMatch;
import com.jia.jnmap.context.Environment;
import com.jia.jnmap.mapper.VulnerabilityMapper;
import com.jia.jnmap.nmap.entity.*;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.stereotype.Component;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.util.List;

@Component
public class VulnerabilityLoader implements ParseEvent, InitializingBean {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityLoader.class);

    @Autowired
    private VulnerabilityMapper vulnerabilityMapper;

    private ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();

    private volatile List<VulnMatchRule> cached;

    private Object lock = new Object();

    public void matchVulnerability(List<NmapScanResult> scanResults) {
        loadMatchRule();
        if (cached == null || cached.size() == 0) {
            return;
        }
        if (scanResults == null || scanResults.size() == 0) {
            return;
        }
        cached.parallelStream().forEach(vulnMatchRule -> {
            List<MatchRule> matchRules = vulnMatchRule.getCveMatchRules();
            if (matchRules == null || matchRules.size() == 0) {
                matchRules = vulnMatchRule.getCnnvdMatchRules();
            }
            if (matchRules == null || matchRules.size() == 0) {
                return;
            }
            for (NmapScanResult scanResult : scanResults) {
                List<PortInfo> portInfos = scanResult.getPortInfos();
                // match port vulnerability
                for (PortInfo portInfo : portInfos) {
                    if (StringUtils.isEmpty(portInfo.getCpe())) {
                        continue;
                    }
                    matchOrVulnerability(vulnMatchRule, matchRules, portInfo);
                }
            }
        });
    }

    public synchronized void cleanCache() {
        cached = null;
    }

    public void loadCnnvd() throws Exception {
        String path = Environment.getProjectPath() + "/data/cnnvd/*.xml";
        Resource[] resources = resolver.getResources("file:" + path);
        SAXParserFactory factory = SAXParserFactory.newInstance();
        SAXParser saxParser = factory.newSAXParser();
        CnnvdParseHandler handler = new CnnvdParseHandler(this);
        for (Resource resource : resources) {
            logger.info("start load cnnvd vulnerability from file : " + resource.getFile().getAbsolutePath());
            try {
                saxParser.parse(resource.getInputStream(), handler);
            } catch (Exception e) {
                logger.error("VulnerabilityLoader.loadCvvnd error", e);
            }
            resource.getFile().delete();
        }
        if (resources.length > 0) {
//            VulnerableStore dto = new VulnerableStore();
//            dto.setId(Identities.uuid());
//            dto.setType(Source.CNNVD);
//            dto.setPublishTime(LocalDate.now());
//            dto.setUpdateTime(LocalDateTime.now());
//            dto.setStatus("成功");
//            VulnerableStore.insert(dto);
        }
    }

    public void loadCve() throws Exception {
        String path = Environment.getProjectPath() + "/data/cve/*.json";
        Resource[] resources = resolver.getResources("file:" + path);
        for (Resource resource : resources) {
            logger.info("start load cve vulnerability from file : " + resource.getFile().getAbsolutePath());
            try {
                CveParseHandler handler = new CveParseHandler(resource, this);
                handler.parse();
            } catch (Exception e) {
                logger.error("VulnerabilityLoader.loadCve " + resource.getFilename() + " error", e);
            }
            resource.getFile().delete();
        }
        if (resources.length > 0) {
//            VulnerableStore dto = new VulnerableStore();
//            dto.setId(Identities.uuid());
//            dto.setType(Source.NVD);
//            dto.setPublishTime(LocalDate.now());
//            dto.setUpdateTime(LocalDateTime.now());
//            dto.setStatus("成功");
//            VulnerableStore.insert(dto);
        }
    }

    @Override
    public void onOnceEvent(Vulnerability vulnerability) {
        if (StringUtils.isNotEmpty(vulnerability.getId())) {
            Vulnerability entity = vulnerabilityMapper.selectOneById(vulnerability.getId());
            if (entity == null) {
                vulnerabilityMapper.insertSelective(vulnerability);
            } else {
                vulnerabilityMapper.updateById(vulnerability, vulnerability.getId());
            }
        } else {
            vulnerabilityMapper.updateByCveId(vulnerability, vulnerability.getCveId());
        }
    }


    private void loadMatchRule() {
        if (cached == null) {
            synchronized (lock) {
                if (cached == null) {
                    cached = vulnerabilityMapper.selectAllVulnMathRule();
                }
            }
        }
    }

    private void matchOrVulnerability(VulnMatchRule vulnMatchRule, List<MatchRule> matchRules, BaseInfo baseInfo) {
        WFN wfn = WFN.forURI23(baseInfo.getCpe());
        for (MatchRule matchRule : matchRules) {
            if (!"or".equals(matchRule.getOperator())) {
                continue;
            }
            if (cpeMatch(matchRule.getCpeList(), wfn)) {
                baseInfo.getVulnerability().add(vulnMatchRule.getId());
            }
        }
    }

    private boolean cpeMatch(List<Cpe> cpeList, WFN wfn) {
        for (Cpe cpe : cpeList) {
            try {
                WFNMatch wfnMatch = new WFNMatch(WFN.forURI23(cpe.getCpe()), true);
                wfnMatch.setVersionStartIncluding(cpe.getStartIncluding());
                wfnMatch.setVersionStartExcluding(cpe.getStartExcluding());
                wfnMatch.setVersionEndIncluding(cpe.getEndIncluding());
                wfnMatch.setVersionEndExcluding(cpe.getEndExcluding());
                if (wfnMatch.isSupersetTo(wfn)) {
                    return true;
                }
            } catch (Exception e) {
            }
        }
        return false;
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        loadCnnvd();
        loadCve();
//        loadMatchRule();
    }

}
